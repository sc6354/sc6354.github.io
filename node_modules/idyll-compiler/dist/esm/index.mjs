import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import _taggedTemplateLiteral from '@babel/runtime/helpers/taggedTemplateLiteral';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { VAR, DERIVED, DATA, queryNodes, isVariableNode, removeNodes, prependChildren, hasChildren, getChildren, getNodeName, isTextNode, hasProperty, getProperty, setValueProperty, VARIABLE, setExpressionProperty, EXPRESSION, VALUE, removeProperty, createComponentNode, mapChildren, createTextNode, convertV1ToV2 } from 'idyll-ast';
import parseFrontMatter from 'gray-matter';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import smartquotes from 'smartquotes';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';

var _templateObject, _templateObject2;

var Lexer = require('lex');

var formatToken = function formatToken(text) {
  text = text || '';
  var results = [];
  results.push('TOKEN_VALUE_START');
  results.push('"' + text.replace(/\"/g, '&quot;').replace(/\\\[/, '[').replace(/\\\]/, ']') + '"');
  results.push('TOKEN_VALUE_END');
  return results;
};

var shouldBreak = function shouldBreak(text) {
  if (text.trim() === '' && (text.match(/\n/g) || []).length > 1) {
    return true;
  }

  return false;
};

var currentInput = null;

var lex = function lex(options) {
  var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _Object$assign = Object.assign({}, {
    row: 1,
    column: 1,
    outer: true,
    skipLists: false,
    inComponent: false,
    gotName: false
  }, options || {}),
      row = _Object$assign.row,
      column = _Object$assign.column,
      outer = _Object$assign.outer,
      skipLists = _Object$assign.skipLists,
      inComponent = _Object$assign.inComponent,
      gotName = _Object$assign.gotName;

  var lexer = new Lexer(function (chr) {
    var errorString = "\n      Error lexing input, unexpected token: ".concat(chr, "\n\n      Found near index ").concat(this.index - 1, ":\n\n      ").concat(currentInput.substring(Math.max(0, this.index - 10), Math.min(this.index + 10, currentInput.length - 1)), "\n    ");
    throw new Error(errorString);
  });

  var recurse = function recurse(str, opts) {
    return lex(Object.assign({
      row: row,
      column: column,
      outer: false
    }, opts || {}), alias)(str).tokens;
  };

  var findAliases = function findAliases(name) {
    var aliasNames = Object.keys(alias);
    return [name].concat(_toConsumableArray(aliasNames.filter(function (aliasName) {
      return alias[aliasName].toLowerCase() === name.toLowerCase();
    }))).join('|');
  };

  var updatePosition = function updatePosition(lexeme) {
    var lines = lexeme.split('\n');
    row += lines.length - 1;

    if (lines.length > 1) {
      column = 0;
    }

    column += lines[lines.length - 1].length;
  }; // Rules at the front are pre-processed,
  // e.g. equations, and code snippets
  // that shouldn't be formatted.


  var equationAliases = findAliases('equation');
  lexer.addRule(new RegExp(String.raw(_templateObject || (_templateObject = _taggedTemplateLiteral(["[s*(", ")s*([^/]]*)s*][\ns\t]*(((?!([s*/(", ")s*])).\n?)*)[\ns\t]*[s*/s*(", ")s*]"], ["\\[\\s*(", ")\\s*([^\\/\\]]*)\\s*\\][\\n\\s\\t]*(((?!(\\[\\s*\\/(", ")\\s*\\])).\\n?)*)[\\n\\s\\t]*\\[\\s*\\/\\s*(", ")\\s*\\]"])), equationAliases, equationAliases, equationAliases), 'i'), function (lexeme, tagName, props, innerText) {
    inComponent = false;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['OPEN_BRACKET', 'COMPONENT_NAME'].concat(formatToken('equation')).concat(recurse(props, {
      inComponent: true,
      gotName: true
    })).concat(['CLOSE_BRACKET']).concat(['WORDS']).concat(formatToken(innerText.trim())).concat(['OPEN_BRACKET', 'FORWARD_SLASH', 'COMPONENT_NAME']).concat(formatToken('equation')).concat(['CLOSE_BRACKET'])];
  });
  var codeAlias = findAliases('code');
  lexer.addRule(new RegExp(String.raw(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["[s*(", ")s*([^/]]*)s*][\ns\t]*(((?!([s*/(", ")s*])).\n?)*)[\ns\t]*[s*/s*(", ")s*]"], ["\\[\\s*(", ")\\s*([^\\/\\]]*)\\s*\\][\\n\\s\\t]*(((?!(\\[\\s*\\/(", ")\\s*\\])).\\n?)*)[\\n\\s\\t]*\\[\\s*\\/\\s*(", ")\\s*\\]"])), codeAlias, codeAlias, codeAlias), 'i'), function (lexeme, tagName, props, innerText) {
    inComponent = false;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['OPEN_BRACKET', 'COMPONENT_NAME'].concat(formatToken('code')).concat(recurse(props, {
      inComponent: true,
      gotName: true
    })).concat(['CLOSE_BRACKET']).concat(['WORDS']).concat(formatToken(innerText.trim())).concat(['OPEN_BRACKET', 'FORWARD_SLASH', 'COMPONENT_NAME']).concat(formatToken('code')).concat(['CLOSE_BRACKET'])];
  });
  lexer.addRule(/`{4}(\S*)\n(((?!````)[\s\S])*[^\n])\n?\s*`{4}/g, function (lexeme, language, text) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['MULTILINE_CODE'].concat(formatToken(language)).concat(formatToken(text))];
  });
  lexer.addRule(/`{3}(\S*)\n(((?!```)[\s\S])*[^\n])\n?\s*`{3}/g, function (lexeme, language, text) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['MULTILINE_CODE'].concat(formatToken(language)).concat(formatToken(text))];
  });
  lexer.addRule(/```(((?!```)[^\n])+)```/, function (lexeme, text) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['INLINE_CODE'].concat(formatToken(text.trim()))];
  });
  lexer.addRule(/``(((?!``)[^\n])+)``/, function (lexeme, text) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['INLINE_CODE'].concat(formatToken(text.trim()))];
  });
  lexer.addRule(/`([^\n\`]+)`/, function (lexeme, text) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['INLINE_CODE'].concat(formatToken(text.trim()))];
  });
  lexer.addRule(/[\s\n]*(#{1,6})\s*([^\n\[]+)[\n\s]*/gm, function (lexeme, hashes, text) {
    if (this.reject) return;
    updatePosition(lexeme);
    return [['BREAK', 'HEADER_' + hashes.length].concat(recurse(text, {
      skipLists: true
    })).concat(['HEADER_END'])];
  });
  lexer.addRule(/[\s\n]*>\s*([^\n\[]+)[\n\s]*/gm, function (lexeme, text) {
    if (this.reject) return;
    updatePosition(lexeme);
    return [['BREAK', 'QUOTE_START'].concat(recurse(text, {
      skipLists: true
    })).concat(['QUOTE_END'])];
  });
  lexer.addRule(/\*\*([^\s\n][^\*]*[^\s\n])\*\*(\s*)/g, function (lexeme, text, trailingSpace) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    var ret = ['STRONG'].concat(recurse(text, {
      skipLists: true
    })).concat(['STRONG_END']);

    if (trailingSpace) {
      if (shouldBreak(trailingSpace)) {
        ret = ret.concat(['BREAK']);
      } else {
        ret = ret.concat(['WORDS']).concat(formatToken(trailingSpace));
      }
    }

    return [ret];
  });
  lexer.addRule(/__([^\s\n][^_]*[^\s\n])__(\s*)/g, function (lexeme, text, trailingSpace) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    var ret = ['STRONG'].concat(recurse(text, {
      skipLists: true
    })).concat(['STRONG_END']);

    if (trailingSpace) {
      if (shouldBreak(trailingSpace)) {
        ret = ret.concat(['BREAK']);
      } else {
        ret = ret.concat(['WORDS']).concat(formatToken(trailingSpace));
      }
    }

    return [ret];
  });
  lexer.addRule(/\*([^\s\n\*][^\*]*[^\s\n\*])\*(\s*)/g, function (lexeme, text, trailingSpace) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    var ret = ['EM'].concat(recurse(text, {
      skipLists: true
    })).concat(['EM_END']);

    if (trailingSpace) {
      if (shouldBreak(trailingSpace)) {
        ret = ret.concat(['BREAK']);
      } else {
        ret = ret.concat(['WORDS']).concat(formatToken(trailingSpace));
      }
    }

    return [ret];
  });
  lexer.addRule(/_([^\s\n_][^_]*[^\s\n_])_(\s*)/g, function (lexeme, text, trailingSpace) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    var ret = ['EM'].concat(recurse(text, {
      skipLists: true
    })).concat(['EM_END']);

    if (trailingSpace) {
      if (shouldBreak(trailingSpace)) {
        ret = ret.concat(['BREAK']);
      } else {
        ret = ret.concat(['WORDS']).concat(formatToken(trailingSpace));
      }
    }

    return [ret];
  });
  lexer.addRule(/^\s*([\-\*]\s+([^\n]*)\n)*([\-\*]\s+([^\n]*)\n?)/gm, function (lexeme) {
    this.reject = inComponent || skipLists;
    if (this.reject) return;
    updatePosition(lexeme);
    var items = lexeme.trim().split('\n');
    var matches = items.map(function (item) {
      return /[\-\*]\s*([^\n]*)/.exec(item)[1];
    });
    var output = ['BREAK', 'UNORDERED_LIST'];
    matches.forEach(function (item) {
      output = output.concat(['LIST_ITEM']).concat(recurse(item.trim() || ' '));
    });
    return [output.concat(['LIST_END'])];
  });
  lexer.addRule(/^\s*(\d+\.\s+([^\n]*)\n)*(\d+\.\s+([^\n]*)\n?)/gm, function (lexeme) {
    this.reject = inComponent || skipLists;
    if (this.reject) return;
    updatePosition(lexeme);
    var items = lexeme.trim().split('\n');
    var matches = items.map(function (item) {
      return /\d+\.\s*([^\n]*)/.exec(item)[1];
    });
    var output = ['BREAK', 'ORDERED_LIST'];
    matches.forEach(function (item) {
      output = output.concat(['LIST_ITEM']).concat(recurse(item));
    });
    return [output.concat(['LIST_END'])];
  });
  lexer.addRule(/\s*~((\s*\w*\s*(:?=)\s*[^\n,]*)[^\n,](,[^\n]\s*\w*\s*(:?=)\s*[^\n,]*)*)/g, function (lexeme, variableDeclarations) {
    if (this.reject) return;
    updatePosition(lexeme);
    var output = [];
    variableDeclarations.split(',').forEach(function (declaration) {
      if (declaration[declaration.indexOf('=') - 1] === ':') {
        output = output.concat(['OPEN_BRACKET', 'COMPONENT_NAME']).concat(formatToken('derived')).concat(['COMPONENT_WORD']).concat(formatToken('name')).concat('PARAM_SEPARATOR', 'COMPONENT_WORD').concat(formatToken(declaration.split(':=')[0].trim())).concat(['COMPONENT_WORD']).concat(formatToken('value')).concat(['PARAM_SEPARATOR']).concat(['EXPRESSION']).concat(formatToken('`' + declaration.split(':=')[1].trim() + '`')).concat(['FORWARD_SLASH', 'CLOSE_BRACKET']);
      } else {
        output = output.concat(['OPEN_BRACKET', 'COMPONENT_NAME']).concat(formatToken('var')).concat(['COMPONENT_WORD']).concat(formatToken('name')).concat('PARAM_SEPARATOR', 'COMPONENT_WORD').concat(formatToken(declaration.split('=')[0].trim())).concat(['COMPONENT_WORD']).concat(formatToken('value')).concat('PARAM_SEPARATOR').concat(recurse(declaration.split('=')[1].trim(), {
          inComponent: true
        })).concat(['FORWARD_SLASH', 'CLOSE_BRACKET']);
      }
    });
    return [output];
  });
  lexer.addRule(/!\[([^\]]*)\]\(([^\)]*)\)/, function (lexeme, text, link) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['IMAGE'].concat(formatToken(text)).concat(formatToken(link))];
  });
  lexer.addRule(/\[([^\]]*)\]\(([^\)]*)\)/, function (lexeme, text, link) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['LINK'].concat(formatToken(text)).concat(formatToken(link))];
  });
  lexer.addRule(/(\n\s*\/\/[^\n]*|\/\/\s+[^\n]*)/, function (lexeme) {
    updatePosition(lexeme);

    if (lexeme.startsWith('\n')) {
      return [['BREAK']];
    }
  });
  lexer.addRule(/\/(\n?[^`\*\[\/\n\]!\\\d_])*/gm, function (lexeme) {
    this.reject = inComponent || lexeme.trim() === '';
    if (this.reject) return;
    updatePosition(lexeme);
    return [['WORDS'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/(\n?[^`\*\[\/\n\]!\\\d_])+/, function (lexeme) {
    this.reject = inComponent || lexeme.trim() === '';
    if (this.reject) return;
    updatePosition(lexeme);
    return [['WORDS'].concat(formatToken(lexeme))];
  }); // Match on separately so we can greedily match the
  // other tags.

  lexer.addRule(/[!\d\*_`] */, function (lexeme) {
    this.reject = inComponent || lexeme.trim() === '';
    if (this.reject) return;
    updatePosition(lexeme);
    return [['WORDS'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/\\[\[\]]?/, function (lexeme) {
    this.reject = inComponent || lexeme.trim() === '';
    if (this.reject) return;
    updatePosition(lexeme);
    return [['WORDS'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/\s*\n{2,}\s*/, function (lexeme) {
    this.reject = inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['BREAK']];
  });
  lexer.addRule(/[ \t\n]+/, function (lexeme) {
    updatePosition(lexeme);
  });
  lexer.addRule(/\[/, function (lexeme) {
    inComponent = true;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['OPEN_BRACKET']];
  });
  lexer.addRule(/\]([ ]*)/, function (lexeme, trailingSpace) {
    inComponent = false;
    gotName = false;
    if (this.reject) return;
    updatePosition(lexeme);
    var ret = ['CLOSE_BRACKET'];

    if (trailingSpace) {
      ret = ret.concat(['WORDS']).concat(formatToken(trailingSpace));
    }

    return [ret];
  });
  lexer.addRule(/\//, function (lexeme) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['FORWARD_SLASH']];
  });
  lexer.addRule(/true|false/, function (lexeme) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['BOOLEAN'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/[^+\-0-9:\s\/\]"'`\.]([^:\s\/\]"'`]*[^:\s\/\]"'`\.])*/, function (lexeme) {
    this.reject = !inComponent || gotName;
    if (this.reject) return;
    gotName = true;
    updatePosition(lexeme);
    return [['COMPONENT_NAME'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/[^+\-0-9:\s\/\]"'`\.][^:\s\/\]"'`\.]*/, function (lexeme) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['COMPONENT_WORD'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/`[^`]*`/, function (lexeme) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['EXPRESSION'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/[+\-]?\.?[0-9]+\.?[0-9]*/, function (lexeme) {
    var multiplePeriods = (lexeme.match(new RegExp(/\./, 'g')) || []).length >= 2;
    this.reject = !inComponent || multiplePeriods;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['NUMBER'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/"[^"]*"/, function (lexeme) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['STRING'].concat(formatToken(lexeme))];
  });
  lexer.addRule(/'([^']*)'/, function (lexeme, str) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['STRING'].concat(formatToken('"' + str + '"'))];
  });
  lexer.addRule(/:/, function (lexeme) {
    this.reject = !inComponent;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['PARAM_SEPARATOR']];
  });
  lexer.addRule(/\s*$/, function (lexeme) {
    this.reject = !outer;
    if (this.reject) return;
    updatePosition(lexeme);
    return [['EOF']];
  });
  return function (str) {
    currentInput = str;
    var output = [];
    var positions = [];
    lexer.input = str.trim();
    var token = lexer.lex();

    while (token) {
      output.push(token);
      positions.push([row, column]);
      token = lexer.lex();
    }

    return {
      tokens: output,
      positions: positions
    };
  };
};

var grammar$1 = {exports: {}};

(function (module) {
// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
(function () {
  function id(x) {
    return x[0];
  }

  var grammar = {
    Lexer: undefined,
    ParserRules: [{
      "name": "_$ebnf$1",
      "symbols": []
    }, {
      "name": "_$ebnf$1",
      "symbols": ["_$ebnf$1", "wschar"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "_",
      "symbols": ["_$ebnf$1"],
      "postprocess": function postprocess(d) {
        return null;
      }
    }, {
      "name": "__$ebnf$1",
      "symbols": ["wschar"]
    }, {
      "name": "__$ebnf$1",
      "symbols": ["__$ebnf$1", "wschar"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "__",
      "symbols": ["__$ebnf$1"],
      "postprocess": function postprocess(d) {
        return null;
      }
    }, {
      "name": "wschar",
      "symbols": [/[ \t\n\v\f]/],
      "postprocess": id
    }, {
      "name": "Sourcefile$string$1",
      "symbols": [{
        "literal": "E"
      }, {
        "literal": "O"
      }, {
        "literal": "F"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Sourcefile",
      "symbols": ["Blocks", "Sourcefile$string$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0];
      }
    }, {
      "name": "Blocks$ebnf$1",
      "symbols": []
    }, {
      "name": "Blocks$ebnf$1$subexpression$1$string$1",
      "symbols": [{
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "K"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Blocks$ebnf$1$subexpression$1",
      "symbols": ["Blocks$ebnf$1$subexpression$1$string$1", "__"]
    }, {
      "name": "Blocks$ebnf$1",
      "symbols": ["Blocks$ebnf$1", "Blocks$ebnf$1$subexpression$1"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Blocks$ebnf$2",
      "symbols": []
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$1$string$1",
      "symbols": [{
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "K"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$1$string$1", "__"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$1"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$2$string$1",
      "symbols": [{
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "K"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$2",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$2$string$1", "__"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1", "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$1",
      "symbols": ["BreakBlock", "__", "Blocks$ebnf$2$subexpression$1$subexpression$1$ebnf$1"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$1"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1",
      "symbols": []
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1$subexpression$1$string$1",
      "symbols": [{
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "K"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1$subexpression$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1$subexpression$1$string$1", "__"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1", "Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1$subexpression$1"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Blocks$ebnf$2$subexpression$1$subexpression$2",
      "symbols": ["NoBreakBlock", "__", "Blocks$ebnf$2$subexpression$1$subexpression$2$ebnf$1"]
    }, {
      "name": "Blocks$ebnf$2$subexpression$1",
      "symbols": ["Blocks$ebnf$2$subexpression$1$subexpression$2"]
    }, {
      "name": "Blocks$ebnf$2",
      "symbols": ["Blocks$ebnf$2", "Blocks$ebnf$2$subexpression$1"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Blocks$ebnf$3$subexpression$1",
      "symbols": ["BreakBlock", "__"]
    }, {
      "name": "Blocks$ebnf$3",
      "symbols": ["Blocks$ebnf$3$subexpression$1"],
      "postprocess": id
    }, {
      "name": "Blocks$ebnf$3",
      "symbols": [],
      "postprocess": function postprocess(d) {
        return null;
      }
    }, {
      "name": "Blocks",
      "symbols": ["Blocks$ebnf$1", "Blocks$ebnf$2", "Blocks$ebnf$3"],
      "postprocess": function postprocess(data, location, reject) {
        var blocks = [];
        data[1].forEach(function (d) {
          blocks.push(d[0][0]);
        });

        if (data[2]) {
          blocks.push(data[2][0]);
        }

        return blocks;
      }
    }, {
      "name": "Block$subexpression$1",
      "symbols": ["BreakBlock"]
    }, {
      "name": "Block$subexpression$1",
      "symbols": ["NoBreakBlock"]
    }, {
      "name": "Block",
      "symbols": ["Block$subexpression$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0][0];
      }
    }, {
      "name": "NoBreakBlock$subexpression$1",
      "symbols": ["Header"]
    }, {
      "name": "NoBreakBlock$subexpression$1",
      "symbols": ["Quote"]
    }, {
      "name": "NoBreakBlock$subexpression$1",
      "symbols": ["MultilineCode"]
    }, {
      "name": "NoBreakBlock$subexpression$1",
      "symbols": ["UnorderedList"]
    }, {
      "name": "NoBreakBlock$subexpression$1",
      "symbols": ["OrderedList"]
    }, {
      "name": "NoBreakBlock",
      "symbols": ["NoBreakBlock$subexpression$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0][0];
      }
    }, {
      "name": "BreakBlock$subexpression$1",
      "symbols": ["Paragraph"]
    }, {
      "name": "BreakBlock",
      "symbols": ["BreakBlock$subexpression$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0][0];
      }
    }, {
      "name": "Header$string$1",
      "symbols": [{
        "literal": "H"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "D"
      }, {
        "literal": "E"
      }, {
        "literal": "R"
      }, {
        "literal": "_"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Header$ebnf$1$subexpression$1",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "Header$ebnf$1",
      "symbols": ["Header$ebnf$1$subexpression$1"]
    }, {
      "name": "Header$ebnf$1$subexpression$2",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "Header$ebnf$1",
      "symbols": ["Header$ebnf$1", "Header$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Header$string$2",
      "symbols": [{
        "literal": "H"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "D"
      }, {
        "literal": "E"
      }, {
        "literal": "R"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Header",
      "symbols": ["Header$string$1", /[1-6]/, "Header$ebnf$1", "__", "Header$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[2].map(function (child) {
          children.push(child[1]);
        });
        return ["h" + data[1], [], children];
      }
    }, {
      "name": "Quote$string$1",
      "symbols": [{
        "literal": "Q"
      }, {
        "literal": "U"
      }, {
        "literal": "O"
      }, {
        "literal": "T"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "A"
      }, {
        "literal": "R"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Quote$ebnf$1$subexpression$1",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "Quote$ebnf$1",
      "symbols": ["Quote$ebnf$1$subexpression$1"]
    }, {
      "name": "Quote$ebnf$1$subexpression$2",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "Quote$ebnf$1",
      "symbols": ["Quote$ebnf$1", "Quote$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Quote$string$2",
      "symbols": [{
        "literal": "Q"
      }, {
        "literal": "U"
      }, {
        "literal": "O"
      }, {
        "literal": "T"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Quote",
      "symbols": ["Quote$string$1", "Quote$ebnf$1", "__", "Quote$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[1].map(function (child) {
          children.push(child[1]);
        });
        return ["blockquote", [], children];
      }
    }, {
      "name": "UnorderedList$string$1",
      "symbols": [{
        "literal": "U"
      }, {
        "literal": "N"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }, {
        "literal": "E"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "D"
      }, {
        "literal": "_"
      }, {
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "UnorderedList$ebnf$1$subexpression$1",
      "symbols": ["__", "ListItem"]
    }, {
      "name": "UnorderedList$ebnf$1",
      "symbols": ["UnorderedList$ebnf$1$subexpression$1"]
    }, {
      "name": "UnorderedList$ebnf$1$subexpression$2",
      "symbols": ["__", "ListItem"]
    }, {
      "name": "UnorderedList$ebnf$1",
      "symbols": ["UnorderedList$ebnf$1", "UnorderedList$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "UnorderedList$string$2",
      "symbols": [{
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "UnorderedList",
      "symbols": ["UnorderedList$string$1", "UnorderedList$ebnf$1", "__", "UnorderedList$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[1].map(function (child) {
          children.push(["li", [], child[1]]);
        });
        return ["ul", [], children];
      }
    }, {
      "name": "OrderedList$string$1",
      "symbols": [{
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }, {
        "literal": "E"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "D"
      }, {
        "literal": "_"
      }, {
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OrderedList$ebnf$1$subexpression$1",
      "symbols": ["__", "ListItem"]
    }, {
      "name": "OrderedList$ebnf$1",
      "symbols": ["OrderedList$ebnf$1$subexpression$1"]
    }, {
      "name": "OrderedList$ebnf$1$subexpression$2",
      "symbols": ["__", "ListItem"]
    }, {
      "name": "OrderedList$ebnf$1",
      "symbols": ["OrderedList$ebnf$1", "OrderedList$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "OrderedList$string$2",
      "symbols": [{
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OrderedList",
      "symbols": ["OrderedList$string$1", "OrderedList$ebnf$1", "__", "OrderedList$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[1].map(function (child) {
          children.push(["li", [], child[1]]);
        });
        return ["ol", [], children];
      }
    }, {
      "name": "ListItem$string$1",
      "symbols": [{
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "_"
      }, {
        "literal": "I"
      }, {
        "literal": "T"
      }, {
        "literal": "E"
      }, {
        "literal": "M"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ListItem$ebnf$1$subexpression$1",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "ListItem$ebnf$1",
      "symbols": ["ListItem$ebnf$1$subexpression$1"]
    }, {
      "name": "ListItem$ebnf$1$subexpression$2",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "ListItem$ebnf$1",
      "symbols": ["ListItem$ebnf$1", "ListItem$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "ListItem",
      "symbols": ["ListItem$string$1", "ListItem$ebnf$1"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[1].map(function (child) {
          children.push(child[1]);
        });
        return children;
      }
    }, {
      "name": "MultilineCode$string$1",
      "symbols": [{
        "literal": "M"
      }, {
        "literal": "U"
      }, {
        "literal": "L"
      }, {
        "literal": "T"
      }, {
        "literal": "I"
      }, {
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "N"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "C"
      }, {
        "literal": "O"
      }, {
        "literal": "D"
      }, {
        "literal": "E"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "MultilineCode$ebnf$1$subexpression$1",
      "symbols": ["__", "TokenValue"]
    }, {
      "name": "MultilineCode$ebnf$1",
      "symbols": ["MultilineCode$ebnf$1$subexpression$1"]
    }, {
      "name": "MultilineCode$ebnf$1$subexpression$2",
      "symbols": ["__", "TokenValue"]
    }, {
      "name": "MultilineCode$ebnf$1",
      "symbols": ["MultilineCode$ebnf$1", "MultilineCode$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "MultilineCode",
      "symbols": ["MultilineCode$string$1", "MultilineCode$ebnf$1"],
      "postprocess": function postprocess(data, location, reject) {
        if (data[1].length > 1 && data[1][0][1].trim() !== '') {
          return ["CodeHighlight", [['language', ['value', data[1][0][1]]]], [data[1][1][1]]];
        } else {
          return ["pre", [], [["code", [], [data[1][data[1].length - 1][1]]]]];
        }
      }
    }, {
      "name": "Paragraph$ebnf$1",
      "symbols": []
    }, {
      "name": "Paragraph$ebnf$1$subexpression$1",
      "symbols": ["ParagraphItem", "__"]
    }, {
      "name": "Paragraph$ebnf$1",
      "symbols": ["Paragraph$ebnf$1", "Paragraph$ebnf$1$subexpression$1"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "Paragraph",
      "symbols": ["Paragraph$ebnf$1", "ParagraphItem"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[0].map(function (child) {
          children.push(child[0]);
        });
        children.push(data[1]);
        var lastWasString = false; // If there are multiple strings split across
        // children merge them to avoid issues with
        // Equation and other components that
        // consume their children programatically.

        children = children.reduce(function (acc, c) {
          if (typeof c === 'string' && lastWasString) {
            acc[acc.length - 1] += c;
            lastWasString = true;
          } else if (typeof c === 'string') {
            acc.push(c);
            lastWasString = true;
          } else {
            acc.push(c);
            lastWasString = false;
          }

          return acc;
        }, []);

        if (children.length === 1 && typeof children[0] !== 'string') {
          return children[0];
        } else if (children.filter(function (c) {
          return typeof c === 'string';
        }).length === 0) {
          return ["_idyllContainer", [], children];
        }

        return ["p", [], children];
      }
    }, {
      "name": "ParagraphItem$subexpression$1",
      "symbols": ["Text"]
    }, {
      "name": "ParagraphItem$subexpression$1",
      "symbols": ["ClosedComponent"]
    }, {
      "name": "ParagraphItem$subexpression$1",
      "symbols": ["OpenComponent"]
    }, {
      "name": "ParagraphItem$subexpression$1",
      "symbols": ["TextInline"]
    }, {
      "name": "ParagraphItem",
      "symbols": ["ParagraphItem$subexpression$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0][0];
      }
    }, {
      "name": "Text$string$1",
      "symbols": [{
        "literal": "W"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }, {
        "literal": "S"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "Text",
      "symbols": ["Text$string$1", "__", "TokenValue"],
      "postprocess": function postprocess(data, location, reject) {
        return data[2];
      }
    }, {
      "name": "TextInline$subexpression$1",
      "symbols": ["CodeInline"]
    }, {
      "name": "TextInline$subexpression$1",
      "symbols": ["BoldInline"]
    }, {
      "name": "TextInline$subexpression$1",
      "symbols": ["EmInline"]
    }, {
      "name": "TextInline$subexpression$1",
      "symbols": ["LinkInline"]
    }, {
      "name": "TextInline$subexpression$1",
      "symbols": ["ImageInline"]
    }, {
      "name": "TextInline",
      "symbols": ["TextInline$subexpression$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0][0];
      }
    }, {
      "name": "BoldInline$string$1",
      "symbols": [{
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "R"
      }, {
        "literal": "O"
      }, {
        "literal": "N"
      }, {
        "literal": "G"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "BoldInline$ebnf$1$subexpression$1",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "BoldInline$ebnf$1",
      "symbols": ["BoldInline$ebnf$1$subexpression$1"]
    }, {
      "name": "BoldInline$ebnf$1$subexpression$2",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "BoldInline$ebnf$1",
      "symbols": ["BoldInline$ebnf$1", "BoldInline$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "BoldInline$string$2",
      "symbols": [{
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "R"
      }, {
        "literal": "O"
      }, {
        "literal": "N"
      }, {
        "literal": "G"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "BoldInline",
      "symbols": ["BoldInline$string$1", "BoldInline$ebnf$1", "__", "BoldInline$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[1].map(function (child) {
          children.push(child[1]);
        });
        return ["strong", [], children];
      }
    }, {
      "name": "EmInline$string$1",
      "symbols": [{
        "literal": "E"
      }, {
        "literal": "M"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "EmInline$ebnf$1$subexpression$1",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "EmInline$ebnf$1",
      "symbols": ["EmInline$ebnf$1$subexpression$1"]
    }, {
      "name": "EmInline$ebnf$1$subexpression$2",
      "symbols": ["__", "ParagraphItem"]
    }, {
      "name": "EmInline$ebnf$1",
      "symbols": ["EmInline$ebnf$1", "EmInline$ebnf$1$subexpression$2"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "EmInline$string$2",
      "symbols": [{
        "literal": "E"
      }, {
        "literal": "M"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "EmInline",
      "symbols": ["EmInline$string$1", "EmInline$ebnf$1", "__", "EmInline$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        var children = [];
        data[1].map(function (child) {
          children.push(child[1]);
        });
        return ["em", [], children];
      }
    }, {
      "name": "CodeInline$string$1",
      "symbols": [{
        "literal": "I"
      }, {
        "literal": "N"
      }, {
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "N"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "C"
      }, {
        "literal": "O"
      }, {
        "literal": "D"
      }, {
        "literal": "E"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "CodeInline",
      "symbols": ["CodeInline$string$1", "__", "TokenValue"],
      "postprocess": function postprocess(data, location, reject) {
        return ['code', [], [data[2]]];
      }
    }, {
      "name": "ImageInline$string$1",
      "symbols": [{
        "literal": "I"
      }, {
        "literal": "M"
      }, {
        "literal": "A"
      }, {
        "literal": "G"
      }, {
        "literal": "E"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ImageInline",
      "symbols": ["ImageInline$string$1", "__", "TokenValue", "__", "TokenValue"],
      "postprocess": function postprocess(data, location, reject) {
        return ['img', [["src", ["value", data[4]]], ["alt", ["value", data[2]]]], []];
      }
    }, {
      "name": "LinkInline$string$1",
      "symbols": [{
        "literal": "L"
      }, {
        "literal": "I"
      }, {
        "literal": "N"
      }, {
        "literal": "K"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "LinkInline",
      "symbols": ["LinkInline$string$1", "__", "TokenValue", "__", "TokenValue"],
      "postprocess": function postprocess(data, location, reject) {
        return ['a', [["href", ["value", data[4]]]], [data[2]]];
      }
    }, {
      "name": "OpenComponent",
      "symbols": ["OpenComponentStart", "__", "Blocks", "OpenComponentEnd"],
      "postprocess": function postprocess(data, location, reject) {
        return [data[0][0], data[0][1], data[2] || []];
      }
    }, {
      "name": "OpenComponentStart$string$1",
      "symbols": [{
        "literal": "O"
      }, {
        "literal": "P"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "_"
      }, {
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "C"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OpenComponentStart$string$2",
      "symbols": [{
        "literal": "C"
      }, {
        "literal": "L"
      }, {
        "literal": "O"
      }, {
        "literal": "S"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "C"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OpenComponentStart",
      "symbols": ["OpenComponentStart$string$1", "__", "ComponentName", "__", "ComponentProperties", "OpenComponentStart$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        return [data[2], data[4]];
      }
    }, {
      "name": "OpenComponentEnd$string$1",
      "symbols": [{
        "literal": "O"
      }, {
        "literal": "P"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "_"
      }, {
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "C"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OpenComponentEnd$string$2",
      "symbols": [{
        "literal": "F"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "W"
      }, {
        "literal": "A"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }, {
        "literal": "_"
      }, {
        "literal": "S"
      }, {
        "literal": "L"
      }, {
        "literal": "A"
      }, {
        "literal": "S"
      }, {
        "literal": "H"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OpenComponentEnd$string$3",
      "symbols": [{
        "literal": "C"
      }, {
        "literal": "L"
      }, {
        "literal": "O"
      }, {
        "literal": "S"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "C"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "OpenComponentEnd",
      "symbols": ["OpenComponentEnd$string$1", "__", "OpenComponentEnd$string$2", "__", "ComponentName", "__", "OpenComponentEnd$string$3"],
      "postprocess": function postprocess(data, location, reject) {
        return data;
      }
    }, {
      "name": "ClosedComponent$string$1",
      "symbols": [{
        "literal": "O"
      }, {
        "literal": "P"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "_"
      }, {
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "C"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ClosedComponent$string$2",
      "symbols": [{
        "literal": "F"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "W"
      }, {
        "literal": "A"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }, {
        "literal": "_"
      }, {
        "literal": "S"
      }, {
        "literal": "L"
      }, {
        "literal": "A"
      }, {
        "literal": "S"
      }, {
        "literal": "H"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ClosedComponent$string$3",
      "symbols": [{
        "literal": "C"
      }, {
        "literal": "L"
      }, {
        "literal": "O"
      }, {
        "literal": "S"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "B"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "C"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ClosedComponent",
      "symbols": ["ClosedComponent$string$1", "__", "ComponentName", "__", "ComponentProperties", "ClosedComponent$string$2", "__", "ClosedComponent$string$3"],
      "postprocess": function postprocess(data, location, reject) {
        return [data[2], data[4], []];
      }
    }, {
      "name": "ComponentName$string$1",
      "symbols": [{
        "literal": "C"
      }, {
        "literal": "O"
      }, {
        "literal": "M"
      }, {
        "literal": "P"
      }, {
        "literal": "O"
      }, {
        "literal": "N"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "T"
      }, {
        "literal": "_"
      }, {
        "literal": "N"
      }, {
        "literal": "A"
      }, {
        "literal": "M"
      }, {
        "literal": "E"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentName",
      "symbols": ["ComponentName$string$1", "__", "TokenValue"],
      "postprocess": function postprocess(data, location, reject) {
        return data[2];
      }
    }, {
      "name": "ComponentProperties$ebnf$1",
      "symbols": []
    }, {
      "name": "ComponentProperties$ebnf$1$subexpression$1",
      "symbols": ["ComponentProperty", "__"]
    }, {
      "name": "ComponentProperties$ebnf$1",
      "symbols": ["ComponentProperties$ebnf$1", "ComponentProperties$ebnf$1$subexpression$1"],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "ComponentProperties",
      "symbols": ["ComponentProperties$ebnf$1"],
      "postprocess": function postprocess(data, location, reject) {
        return data[0].map(function (d) {
          return d[0];
        });
      }
    }, {
      "name": "ComponentProperty$string$1",
      "symbols": [{
        "literal": "C"
      }, {
        "literal": "O"
      }, {
        "literal": "M"
      }, {
        "literal": "P"
      }, {
        "literal": "O"
      }, {
        "literal": "N"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "T"
      }, {
        "literal": "_"
      }, {
        "literal": "W"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentProperty$string$2",
      "symbols": [{
        "literal": "P"
      }, {
        "literal": "A"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "M"
      }, {
        "literal": "_"
      }, {
        "literal": "S"
      }, {
        "literal": "E"
      }, {
        "literal": "P"
      }, {
        "literal": "A"
      }, {
        "literal": "R"
      }, {
        "literal": "A"
      }, {
        "literal": "T"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentProperty",
      "symbols": ["ComponentProperty$string$1", "__", "TokenValue", "__", "ComponentProperty$string$2", "__", "ComponentPropertyValue"],
      "postprocess": function postprocess(data, location, reject) {
        var key = data[2];
        var val = data[6];
        return [key, val];
      }
    }, {
      "name": "ComponentPropertyValue$subexpression$1$string$1",
      "symbols": [{
        "literal": "N"
      }, {
        "literal": "U"
      }, {
        "literal": "M"
      }, {
        "literal": "B"
      }, {
        "literal": "E"
      }, {
        "literal": "R"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentPropertyValue$subexpression$1",
      "symbols": ["ComponentPropertyValue$subexpression$1$string$1"]
    }, {
      "name": "ComponentPropertyValue$subexpression$1$string$2",
      "symbols": [{
        "literal": "E"
      }, {
        "literal": "X"
      }, {
        "literal": "P"
      }, {
        "literal": "R"
      }, {
        "literal": "E"
      }, {
        "literal": "S"
      }, {
        "literal": "S"
      }, {
        "literal": "I"
      }, {
        "literal": "O"
      }, {
        "literal": "N"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentPropertyValue$subexpression$1",
      "symbols": ["ComponentPropertyValue$subexpression$1$string$2"]
    }, {
      "name": "ComponentPropertyValue$subexpression$1$string$3",
      "symbols": [{
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "R"
      }, {
        "literal": "I"
      }, {
        "literal": "N"
      }, {
        "literal": "G"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentPropertyValue$subexpression$1",
      "symbols": ["ComponentPropertyValue$subexpression$1$string$3"]
    }, {
      "name": "ComponentPropertyValue$subexpression$1$string$4",
      "symbols": [{
        "literal": "C"
      }, {
        "literal": "O"
      }, {
        "literal": "M"
      }, {
        "literal": "P"
      }, {
        "literal": "O"
      }, {
        "literal": "N"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "T"
      }, {
        "literal": "_"
      }, {
        "literal": "W"
      }, {
        "literal": "O"
      }, {
        "literal": "R"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentPropertyValue$subexpression$1",
      "symbols": ["ComponentPropertyValue$subexpression$1$string$4"]
    }, {
      "name": "ComponentPropertyValue$subexpression$1$string$5",
      "symbols": [{
        "literal": "B"
      }, {
        "literal": "O"
      }, {
        "literal": "O"
      }, {
        "literal": "L"
      }, {
        "literal": "E"
      }, {
        "literal": "A"
      }, {
        "literal": "N"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "ComponentPropertyValue$subexpression$1",
      "symbols": ["ComponentPropertyValue$subexpression$1$string$5"]
    }, {
      "name": "ComponentPropertyValue",
      "symbols": ["ComponentPropertyValue$subexpression$1", "__", "TokenValue"],
      "postprocess": function postprocess(data, location, reject) {
        var t = data[0][0];
        var val = data[2];

        if (t === 'NUMBER') {
          val = +val;
        } else if (t === 'EXPRESSION' || t === 'STRING') {
          val = val.substring(1, val.length - 1);
        } else if (t === 'BOOLEAN') {
          val = val === 'true';
        }

        var typeString = '';

        if (t === 'EXPRESSION') {
          typeString = 'expression';
        } else if (t === 'NUMBER' || t === 'STRING' || t === 'BOOLEAN') {
          typeString = 'value';
        } else if (t === 'COMPONENT_WORD') {
          typeString = 'variable';
        }

        return [typeString, val];
      }
    }, {
      "name": "TokenValue$string$1",
      "symbols": [{
        "literal": "T"
      }, {
        "literal": "O"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "_"
      }, {
        "literal": "V"
      }, {
        "literal": "A"
      }, {
        "literal": "L"
      }, {
        "literal": "U"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "S"
      }, {
        "literal": "T"
      }, {
        "literal": "A"
      }, {
        "literal": "R"
      }, {
        "literal": "T"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "TokenValue$ebnf$1",
      "symbols": []
    }, {
      "name": "TokenValue$ebnf$1",
      "symbols": ["TokenValue$ebnf$1", /[^\"]/],
      "postprocess": function arrpush(d) {
        return d[0].concat([d[1]]);
      }
    }, {
      "name": "TokenValue$string$2",
      "symbols": [{
        "literal": "T"
      }, {
        "literal": "O"
      }, {
        "literal": "K"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "_"
      }, {
        "literal": "V"
      }, {
        "literal": "A"
      }, {
        "literal": "L"
      }, {
        "literal": "U"
      }, {
        "literal": "E"
      }, {
        "literal": "_"
      }, {
        "literal": "E"
      }, {
        "literal": "N"
      }, {
        "literal": "D"
      }],
      "postprocess": function joiner(d) {
        return d.join('');
      }
    }, {
      "name": "TokenValue",
      "symbols": ["TokenValue$string$1", "__", {
        "literal": "\""
      }, "TokenValue$ebnf$1", {
        "literal": "\""
      }, "__", "TokenValue$string$2"],
      "postprocess": function postprocess(data, location, reject) {
        return data[3].join('').replace(/&quot;/g, '"');
      }
    }],
    ParserStart: "Sourcefile"
  };

  {
    module.exports = grammar;
  }
})();
}(grammar$1));

var grammar = grammar$1.exports;

var nearley = require('nearley');

function parse (input, tokenChunks, positions) {
  var p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);

  var processToken = function processToken(token) {
    p.feed(token);

    if (token !== 'EOF') {
      p.feed(' ');
    }
  };

  var processTokenChunk = function processTokenChunk(tokenChunk) {
    tokenChunk.forEach(function (token) {
      if (typeof token === 'string') {
        processToken(token);
      } else {
        processTokenChunk(token);
      }
    });
  };

  tokenChunks.forEach(function (tokenChunk, index) {
    try {
      processTokenChunk(tokenChunk);
    } catch (err) {
      var position = positions[index];
      var message = 'Error parsing input at line ' + position[0] + ', column ' + position[1] + '\n\n' + input.split('\n')[position[0] - 1] + '\n' + Array(Math.max(0, position[1] - 2)).join(' ') + '^^^';
      var e = new Error(message);
      e.row = position[0];
      e.column = position[1];
      throw e;
    }
  });
  var results = p.results;

  if (results.length) {
    if (results.length > 1) {
      console.warn('Warning: this Idyll markup resulted in an ambiguous parse');
    }

    return results[0];
  }

  throw new Error('No parse results');
}

function cleanNewlines(input) {
  return input.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
}

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function pipeline() {
  for (var _len = arguments.length, operations = new Array(_len), _key = 0; _key < _len; _key++) {
    operations[_key] = arguments[_key];
  }

  operations = operations.flat();
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input) {
      var result,
          _len2,
          args,
          _key2,
          _iterator,
          _step,
          op,
          _args = arguments;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = input;

              for (_len2 = _args.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = _args[_key2];
              }

              _iterator = _createForOfIteratorHelper$5(operations);
              _context.prev = 3;

              _iterator.s();

            case 5:
              if ((_step = _iterator.n()).done) {
                _context.next = 12;
                break;
              }

              op = _step.value;
              _context.next = 9;
              return op.apply(void 0, [result].concat(args));

            case 9:
              result = _context.sent;

            case 10:
              _context.next = 5;
              break;

            case 12:
              _context.next = 17;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](3);

              _iterator.e(_context.t0);

            case 17:
              _context.prev = 17;

              _iterator.f();

              return _context.finish(17);

            case 20:
              return _context.abrupt("return", result);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 14, 17, 20]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}

var _rank;
var rank = (_rank = {}, _defineProperty(_rank, VAR, 0), _defineProperty(_rank, DERIVED, 1), _defineProperty(_rank, DATA, 2), _rank);

function hoistVariables(ast) {
  var variableNodes = queryNodes(ast, isVariableNode);
  variableNodes.sort(function (a, b) {
    return rank[a.type] - rank[b.type];
  });
  removeNodes(ast, isVariableNode);
  prependChildren(ast, variableNodes);
  return ast;
}

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var IDYLL_CONTAINER = '_idyllContainer';

function flattenChildren(node) {
  if (hasChildren(node)) {
    var flat = [];

    var _iterator = _createForOfIteratorHelper$4(getChildren(node)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;

        if (getNodeName(child) === IDYLL_CONTAINER) {
          flat.push.apply(flat, child.children);
        } else {
          flat.push(child);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    node.children = flat;
  }

  return node;
}

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var TEXT_CONTAINER$1 = 'TextContainer';
var FULLWIDTH = 'fullwidth';
var SCROLLER = 'scroller';
var CLASS_NAME = 'className';

function makeFullWidth(ast) {
  var textNodes = [];
  var reduced = [];

  var _iterator = _createForOfIteratorHelper$3(getChildren(ast)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;

      try {
        var ist = isTextNode(child);
      } catch (err) {
        console.error(err);
        console.error('AST', JSON.stringify(ast, 0, 2));
      }

      if (isTextNode(child)) {
        textNodes.push(child);
        continue;
      }

      var childName = getNodeName(child).toLowerCase();

      if ([DERIVED, VAR, DATA, FULLWIDTH, SCROLLER].includes(childName) || hasProperty(child, 'fullWidth')) {
        if (childName === FULLWIDTH) {
          child.name = 'div';
          var className = getProperty(child, CLASS_NAME);

          if (className) {
            switch (className.type) {
              case VALUE:
                setValueProperty(child, CLASS_NAME, 'fullWidth ' + className.value);
                break;

              case EXPRESSION:
              case VARIABLE:
                setExpressionProperty(child, CLASS_NAME, "\"fullWidth \" + (".concat(className.value, ")"));
                break;

              default:
                setValueProperty(child, CLASS_NAME, 'fullWidth');
            }
          } else {
            setValueProperty(child, CLASS_NAME, 'fullWidth');
          }
        } else {
          removeProperty(child, 'fullWidth');
        }

        if (textNodes.length) {
          reduced.push(createComponentNode(TEXT_CONTAINER$1, null, textNodes));
          textNodes = [];
        }

        reduced.push(child);
      } else {
        textNodes.push(child);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (textNodes.length) {
    reduced.push(createComponentNode(TEXT_CONTAINER$1, null, textNodes));
  }

  ast.children = reduced;
  return ast;
}

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var TEXT_CONTAINER = 'TextContainer';

function wrapText(ast) {
  var query = function query(node) {
    return getNodeName(node) === TEXT_CONTAINER;
  };

  var _iterator = _createForOfIteratorHelper$2(queryNodes(ast, query)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      mapChildren(node, function (child) {
        return isTextNode(child) ? createComponentNode('p', null, child) : child;
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return ast;
}

var RAW_NODES$1 = ['pre', 'code', 'codehighlight', 'equation'];

function cleanResults(ast) {
  if (isTextNode(ast)) {
    return ast;
  }

  return mapChildren(ast, function (node) {
    if (isTextNode(node)) {
      return node;
    }

    flattenChildren(node);
    var name = getNodeName(node).toLowerCase();
    var children = getChildren(node); // if not a section, step, or textcontainer component &&
    // node has one child &&
    // node child is not a textnode &&
    // node child is a p component &&
    // node child has children, THEN
    //  if node is a raw node, return the child nodes' children as node's value
    //  else recursively clean using grandchild rather than child
    // ELSE
    //  if node is a raw node, return it as is
    // ELSE recursively clean children

    if (!['section', 'step', 'textcontainer'].includes(name) && children.length === 1 && getNodeName(children[0]) === 'p' && getChildren(children[0]).length) {
      if (!RAW_NODES$1.includes(name)) {
        cleanResults(children[0]);
      }

      node.children = children[0].children;
    } else {
      // don't apply cleaning to codeblocks
      if (!RAW_NODES$1.includes(name)) {
        cleanResults(node);
      }
    }

    return node;
  });
}

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var RAW_NODES = ['pre', 'code', 'codehighlight', 'equation'];

function smartQuotes(ast, context) {
  if (context.smartquotes) {
    smartQuoteHelper(ast);
  }

  return ast;
}

function smartQuoteHelper(node) {
  if (isTextNode(node)) {
    node.value = smartquotes(node.value);
  } else {
    var name = getNodeName(node).toLowerCase();

    if (RAW_NODES.includes(name)) {
      return;
    }

    var _iterator = _createForOfIteratorHelper$1(getChildren(node)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        smartQuoteHelper(child);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
}

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var urlPattern = /(http|https|ftp|ftps)\:\/\/([a-zA-Z0-9\-\.]+\.)+[a-zA-Z]{2,3}(\/\S*)?/g;
/**
 * Plugin to find find valid urls in text nodes and make them hyperlinks.
 * @param {*} ast AST passes from the parser representing the document.
 * @return A new modified AST with all hyperlinks linkified.
 */

function autoLinkify(node) {
  return isTextNode(node) ? linkifyNode(node) : mapChildren(node, autoLinkify);
}

function linkifyNode(node) {
  var textIndex = 0;
  var text = node.value;
  var nodes = [];

  var _iterator = _createForOfIteratorHelper(text.matchAll(urlPattern)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var match = _step.value;

      var _match = _slicedToArray(match, 1),
          href = _match[0];

      var index = match.index; // extract prior text to new text node

      if (index > textIndex) {
        nodes.push(createTextNode(text.slice(textIndex, index)));
      } // generate hyperlink


      nodes.push(createComponentNode('a', {
        href: {
          type: VALUE,
          value: href
        }
      }, [createTextNode(href)])); // update index into source text

      textIndex = index + href.length;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (!nodes.length) {
    return node;
  } // extract any trailing text to new text node


  if (textIndex < text.length) {
    nodes.push(createTextNode(text.slice(textIndex)));
  }

  return createComponentNode('span', null, nodes);
}

var defaultPlugins = [hoistVariables, flattenChildren, makeFullWidth, wrapText, cleanResults, smartQuotes, autoLinkify];
function index (_x) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input) {
    var context,
        _parseFrontMatter,
        content,
        data,
        lex$1,
        lexResults,
        ast,
        transform,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            // prepare compiler options
            context = Object.assign({
              spellcheck: false,
              smartquotes: true
            }, context); // pre-process input text

            input = cleanNewlines(input).trim(); // parse YAML front matter

            _parseFrontMatter = parseFrontMatter(input), content = _parseFrontMatter.content, data = _parseFrontMatter.data;
            context.metadata = data || {}; // perform lexing

            lex$1 = lex({}, context.alias);
            lexResults = '';
            _context.prev = 7;
            lexResults = lex$1(content);
            _context.next = 15;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](7);
            console.warn("\nError parsing Idyll markup:\n".concat(_context.t0.message));
            throw _context.t0;

          case 15:
            _context.prev = 15;
            ast = parse(content, lexResults.tokens, lexResults.positions);
            ast = convertV1ToV2(ast);
            _context.next = 24;
            break;

          case 20:
            _context.prev = 20;
            _context.t1 = _context["catch"](15);
            console.warn("\nError parsing Idyll markup:\n".concat(_context.t1.message));
            throw _context.t1;

          case 24:
            // construct AST transformation pipeline
            transform = pipeline(defaultPlugins, context.plugins || []); // apply AST transformations and return result

            return _context.abrupt("return", transform(ast, context));

          case 26:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 11], [15, 20]]);
  }));
  return _ref.apply(this, arguments);
}

export { index as default };
//# sourceMappingURL=index.mjs.map
